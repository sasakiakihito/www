<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <title>動作分析システム</title>
    <style>
        :root {
            --bg-color: #1a1a1a;
            --primary-color: #03a9f4; /* Bright Blue */
            --secondary-color: #e91e63; /* Pink */
            --text-color: #e0e0e0;
            --container-bg: #2a2a2a;
            --font-family: 'Segoe UI', 'Meiryo', 'Roboto', sans-serif;
        }
        body {
            font-family: var(--font-family);
            display: flex;
            flex-direction: column;
            align-items: center;
            margin: 0;
            background-color: var(--bg-color);
            color: var(--text-color);
        }
        h1 {
            color: var(--primary-color);
            letter-spacing: 2px;
            text-shadow: 0 0 5px var(--primary-color);
            margin-top: 20px;
        }
        #settings-container {
            background-color: var(--container-bg);
            padding: 20px;
            border-radius: 8px;
            margin: 15px 0;
            display: flex;
            align-items: center;
            gap: 15px;
            border: 1px solid var(--primary-color);
        }
        #settings-container label {
            font-size: 1.1em;
        }
        #duration-input {
            width: 80px;
            padding: 8px;
            background-color: #333;
            border: 1px solid #555;
            color: var(--text-color);
            font-size: 1.1em;
            text-align: center;
            border-radius: 4px;
        }
        #start-button {
            padding: 10px 20px;
            font-size: 1.1em;
            font-weight: bold;
            color: white;
            background-color: var(--primary-color);
            border: none;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        #start-button:hover {
            box-shadow: 0 0 15px var(--primary-color);
            transform: translateY(-2px);
        }
        #main-container {
            position: relative;
            width: 640px;
            height: 480px;
            margin: 20px auto;
            border-radius: 8px;
            overflow: hidden;
            border: 2px solid var(--primary-color);
            box-shadow: 0 0 20px rgba(3, 169, 244, 0.5);
        }
        #video, #output-canvas {
            position: absolute; top: 0; left: 0;
            transform: scaleX(-1); /* Mirror view */
        }
        #countdown {
            position: absolute; top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            font-size: 150px;
            font-weight: bold;
            color: rgba(255, 255, 255, 0.9);
            text-shadow: 0 0 25px var(--secondary-color);
            z-index: 10;
        }
        #status {
            font-size: 1.2em;
            margin-top: 10px;
            height: 2em;
            color: var(--text-color);
            font-weight: bold;
        }
        #chart-container {
            width: 80%;
            max-width: 720px;
            margin-top: 520px;
            padding: 20px;
            background: var(--container-bg);
            border-radius: 8px;
            border: 1px solid #444;
        }
        /* Chart.js dark theme overrides */
        .chart-legend-item, .chart-axis-label { color: var(--text-color) !important; }
    </style>
</head>
<body>

    <h1>應援團　二呼一拍 分析 装置</h1>

    <div id="settings-container">
        <label for="duration-input">計測時間 (秒):</label>
        <input type="number" id="duration-input" value="10" min="1" max="120">
        <button id="start-button">▶ 計測開始</button>
    </div>

    <div id="status">待機中...</div>

    <div id="main-container" style="display: none;">
        <video id="video" width="640" height="480" autoplay muted playsinline></video>
        <canvas id="output-canvas" width="640" height="480"></canvas>
        <div id="countdown"></div>
    </div>

    <div id="chart-container" style="display: none;">
        <canvas id="speed-chart"></canvas>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-core@4.20.0"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-converter@4.20.0"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-backend-webgl@4.20.0"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/pose-detection@2.1.3"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.3"></script>
    
    <script>
        // DOM Elements
        const durationInput = document.getElementById('duration-input');
        const startButton = document.getElementById('start-button');
        const settingsContainer = document.getElementById('settings-container');
        const videoElement = document.getElementById('video');
        const canvasElement = document.getElementById('output-canvas');
        const canvasCtx = canvasElement.getContext('2d');
        const countdownElement = document.getElementById('countdown');
        const statusElement = document.getElementById('status');
        const mainContainer = document.getElementById('main-container');
        const chartContainer = document.getElementById('chart-container');

        let detector;
        let isRecording = false;
        let animationFrameId;
        const leftWristData = [];
        const rightWristData = [];

        const POSE_CONNECTIONS = [
            ['left_shoulder', 'left_elbow'], ['left_elbow', 'left_wrist'],
            ['right_shoulder', 'right_elbow'], ['right_elbow', 'right_wrist']
        ];

        // *** 修正点: 開始ボタンにイベントリスナーを追加 ***
        startButton.addEventListener('click', () => {
            const durationSeconds = parseInt(durationInput.value, 10);
            if (isNaN(durationSeconds) || durationSeconds <= 0) {
                statusElement.textContent = "エラー: 有効な秒数を入力してください。";
                return;
            }
            
            settingsContainer.style.display = 'none'; // 設定UIを隠す
            mainContainer.style.display = 'block';   // カメラ映像を表示
            statusElement.textContent = "システムを起動中...";
            
            main(durationSeconds); // 入力された秒数でメイン処理を開始
        });

        async function main(durationSeconds) {
            try {
                statusElement.textContent = 'カメラにアクセスしています...';
                const stream = await navigator.mediaDevices.getUserMedia({ video: true });
                videoElement.srcObject = stream;
                await new Promise((resolve) => {
                    videoElement.onloadedmetadata = () => resolve();
                });
                
                statusElement.textContent = 'AIモデルを読み込んでいます...';
                const detectorConfig = { modelType: poseDetection.movenet.modelType.SINGLEPOSE_LIGHTNING };
                detector = await poseDetection.createDetector(poseDetection.SupportedModels.MoveNet, detectorConfig);
                
                await startCountdown();
                startRecording(durationSeconds);

            } catch (error) {
                console.error("エラーが発生しました:", error);
                statusElement.textContent = `エラー: ${error.message}`;
                settingsContainer.style.display = 'flex'; // エラー時は設定UIを再表示
                mainContainer.style.display = 'none';
            }
        }

        function startCountdown() {
            return new Promise(resolve => {
                let count = 5;
                statusElement.textContent = '5秒後に計測を開始します。';
                countdownElement.textContent = count;

                const interval = setInterval(() => {
                    count--;
                    if (count > 0) {
                        countdownElement.textContent = count;
                    } else {
                        clearInterval(interval);
                        countdownElement.style.display = 'none';
                        resolve();
                    }
                }, 1000);
            });
        }
        
        function startRecording(durationSeconds) {
            const DURATION_MS = durationSeconds * 1000;
            isRecording = true;
            statusElement.textContent = `計測中... (残り${durationSeconds.toFixed(1)}秒)`;
            
            leftWristData.length = 0;
            rightWristData.length = 0;
            
            detectPose();

            const startTime = performance.now();

            const countdownInterval = setInterval(() => {
                const elapsedTime = performance.now() - startTime;
                const remainingTime = DURATION_MS - elapsedTime;
                if (remainingTime > 0 && isRecording) {
                    statusElement.textContent = `計測中... (残り${(remainingTime / 1000).toFixed(1)}秒)`;
                } else {
                    clearInterval(countdownInterval);
                }
            }, 100);

            setTimeout(() => {
                isRecording = false;
                cancelAnimationFrame(animationFrameId);
                statusElement.textContent = '計測完了。データを解析中...';
                videoElement.srcObject.getTracks().forEach(track => track.stop());
                processAndDisplayChart();
            }, DURATION_MS);
        }

        async function detectPose() {
            if (!detector || !isRecording) return;
            const poses = await detector.estimatePoses(videoElement, {flipHorizontal: false});
            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);
            if (poses && poses.length > 0) {
                drawSkeleton(poses[0].keypoints);
                recordData(poses[0].keypoints);
            }
            animationFrameId = requestAnimationFrame(detectPose);
        }
        
        function recordData(keypoints) {
            const now = performance.now();
            const leftWrist = keypoints.find(k => k.name === 'left_wrist');
            const rightWrist = keypoints.find(k => k.name === 'right_wrist');
            if (leftWrist && leftWrist.score > 0.3) leftWristData.push({ x: leftWrist.x, y: leftWrist.y, time: now });
            if (rightWrist && rightWrist.score > 0.3) rightWristData.push({ x: rightWrist.x, y: rightWrist.y, time: now });
        }

        function drawSkeleton(keypoints) {
            const keypointsMap = new Map(keypoints.map(k => [k.name, k]));
            canvasCtx.lineWidth = 5;

            POSE_CONNECTIONS.forEach((pair, index) => {
                canvasCtx.strokeStyle = index < 2 ? 'rgba(233, 30, 99, 0.8)' : 'rgba(3, 169, 244, 0.8)'; // Left: Pink, Right: Blue
                const [start, end] = pair.map(name => keypointsMap.get(name));
                if (start && end && start.score > 0.3 && end.score > 0.3) {
                    canvasCtx.beginPath();
                    canvasCtx.moveTo(start.x, start.y);
                    canvasCtx.lineTo(end.x, end.y);
                    canvasCtx.stroke();
                }
            });
        }
        
        function processAndDisplayChart() {
            const leftSpeeds = calculateSpeeds(leftWristData);
            const rightSpeeds = calculateSpeeds(rightWristData);
            
            chartContainer.style.display = 'block';
            statusElement.textContent = "解析完了。";
            
            // Chart.jsのデフォルトカラーを設定
            Chart.defaults.color = 'rgba(224, 224, 224, 0.8)';
            Chart.defaults.borderColor = 'rgba(224, 224, 224, 0.2)';

            const chartCtx = document.getElementById('speed-chart').getContext('2d');
            new Chart(chartCtx, {
                type: 'line',
                data: {
                    datasets: [
                        { label: '左手首 (Left)', data: leftSpeeds, borderColor: '#e91e63', backgroundColor: '#e91e63', showLine: true, tension: 0.1 },
                        { label: '右手首 (Right)', data: rightSpeeds, borderColor: '#03a9f4', backgroundColor: '#03a9f4', showLine: true, tension: 0.1 }
                    ]
                },
                options: {
                    scales: {
                        x: { type: 'linear', position: 'bottom', title: { display: true, text: '経過時間 (秒)' }},
                        y: { beginAtZero: true, title: { display: true, text: '速度 (ピクセル/秒)' }}
                    },
                    responsive: true,
                }
            });
        }

        function calculateSpeeds(data) {
            const speeds = [];
            if (data.length < 2) return speeds;
            const startTime = data[0].time;
            for (let i = 1; i < data.length; i++) {
                const p1 = data[i-1];
                const p2 = data[i];
                const distance = Math.sqrt(Math.pow(p2.x - p1.x, 2) + Math.pow(p2.y - p1.y, 2));
                const timeDiff = (p2.time - p1.time) / 1000;
                if (timeDiff > 0.01) {
                    const speed = distance / timeDiff;
                    const elapsedTime = (p2.time - startTime) / 1000;
                    speeds.push({ x: elapsedTime, y: speed });
                }
            }
            return speeds;
        }
    </script>
</body>
</html>
